# ❓ Questions
## [Day1(2021.06.10)](#Day01)
- HTTP 메소드 중 GET과 POST를 비교하여 설명해주세요.
- 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유? 
- 그 외에 다른 메소드 방식을 설명해주세요.
- PUT & PATCH 차이점을 설명해주세요.
- TCP와 UDP에 대해 설명해주세요.
- 흐름제어와 혼잡제어에 대해 설명해주세요.
- TCP의 연결(3-way handshaking)과 해제(4-way handshaking) 과정을 설명해주세요.
- 만약 Server에서 FIN 세그먼트를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?

## [Day2(2021.06.17)](#Day02)
- 쿠키와 세션을 사용하는 이유를 HTTP 특징과 연관지어서 설명해주세요.
- 보안성이 낮은 쿠키 대신 세션을 사용하면 되는데 그렇게 하지않는 이유는 무엇일까요?
- HTTP & HTTPS에 대해 설명해주세요.
- 네트워크에서 프록시의 종류 두가지를 말하시오
- 로드밸런싱이 필요해진 배경을 설명하시오.
- 로드밸런싱의 방법을 두 가지 이상 설명하시오.

## [Day3(2021.06.24)](#Day03)
## Day01
### 💡 HTTP 메소드 중 GET과 POST를 비교하여 설명해주세요.
- GET, POST 메소드는 HTTP 프로토콜을 이용해서 서버에 데이터(요청 정보)를 `전달`할 때 사용하는 방식이다.
- 이 때, HTTP 요청에 포함되는 메소드는 서버가 클라이언트의 요청에 응답하기 위해서 수행해야할 `행동`을 나타내는 역할을 한다.
- GET은 가져올 때, POST는 수행할 때 사용한다.
- GET
    - 서버로부터 정보를 조회하는데 사용한다. 
    - URL에 요청 정보를 포함하여 전송한다.
    - 데이터의 크기는 제한적이다. (한 번 요청 시 전송 데이터(주솟값 + 파라미터)의 양은 255자로 제한된다.)
    - 보안에 취약하다.
    - 캐싱할 수 있다. 따라서 POST 방식보다 빠르다.
        - 캐싱이란 한번 접근 후, 또 요청할시 빠르게 접근하기 위해 레지스터에 데이터를 저장시켜 놓는 것.
- POST
    - 서버의 값이나 상태를 바꾸기 위해 사용한다.
    - HTTP Body에 데이터를 포함해서 전달한다. 객체 등
    - 대용량 데이터를 전송할 수 있다.
    - GET 방식보다 보안상 안전하다.



### 💡 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?  
- 먼저 POST 방식은 안전X, 멱등X 하게 설계되었기 때문에 원하는 조회 결과를 얻을 수 없습니다.
- 반면에 GET 방식은 Idempotent(멱등)하게 설계되었기 때문에 한 번을 조회하던, 여러번 조회를 하던 언제나 동일한 응답이 돌아오게 됩니다. 따라서 웹페이지 조회, 게시판 조회 등 조회를 하는데 GET 방식을 사용한다.
- 웹에서 모든 리소스는 링크(Link) 할 수 있는 URL이 필요하다.
    - 다른 사람한테 웹 페이지 주소를 공유하기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다. 즉, 어떤 웹페이지로 바로 이동하기 위해서는 해당 링크의 정보가 필요하다.
    - 그런데 POST는 요청 데이터가 Body에 담겨 있어서 링크 정보를 가져올 수 없기 때문에 GET방식을 사용한다.



### 💡 그 외에 다른 메소드 방식을 설명해주세요.
- PUT 요청은 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성한다.
- PATCH 요청은 서버에 존재하는 데이터를 일부 수정한다. 보내지 않은 필드는 수정되지 않는다.
- DELETE 요청은 서버에 데이터를 제거할 것을 요청. 존재하지 않아도 동일하게 동작한다.



### 💡 PUT & PATCH 차이점을 설명해주세요.
- PUT 요청은 모든 데이터를 수정하는 역할을 한다. 만약 데이터 수정 시에, 보내지 않은 데이터가 있다면 해당 값은 null로 수정된다.
- PATCH 요청은 일부 데이터만을 수정하는 역할을 한다. 따라서 보내지 않은 필드는 수정되지 않는다.



### 💡 TCP와 UDP에 대해 설명해주세요.  
- TCP
    - 신뢰성 있는 데이터 통신을 가능하게 해주는 프로토콜이다.
    - 연결형 서비스로 가상 회선 방식을 이용한 일대일 연결만 가능하다.
    - 흐름제어, 혼잡제어, 오류제어를 제공하기 때문에 신뢰성을 보장된다.
    - 데이터의 순차 전송을 보장한다.
    - 패킷을 조금만 손실해도 재전송을 한다.
    - 매번 Connection을 연결해야 하기 때문에 속도가 상대적으로 느리다.
    - 높은 신뢰도를 요하는 서비스에 적합
        - HTTP통신, 이메일, 파일 전송

- UDP
    - TCP보다 신뢰성을 떨어지지만, 전송 속도가 일반적으로 빠른 프로토콜이다.
    - 비연결형 서비스로 연결 설정 없이 단방향으로로 데이터를 전송한다.
    - 흐름제어, 혼잡제어를 제공하지 않기 때문에 신뢰성이 낮다.
    - 속도가 빠르다.
    - 신뢰성이 중요하지 않은 서비스에 적합
        - 영상 스트리밍, DNS



### 💡 흐름제어와 혼잡제어에 대해 설명해주세요.  
- 흐름제어
    - 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절해서 수신자의 버퍼 오버플로우를 방지하기 위한 방법이다.
- 혼잡제어
    - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 송신측에서 데이터를 보내는 속도를 제어하는 방법이다.



### 💡 TCP의 연결(3-way handshaking)과 해제(4-way handshaking) 과정을 설명해주세요.  
- 3-way Handshaking
*데이터를 전송하기 위해 네트워크 연결을 설정하는 과정이다. (가상회선을 수립)*  
    1. 클라이언트가 서버측에 연결 요청 메시지 전송 (SYN)
        - 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자(n)로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    2. 서버는 클라이언트의 요청을 승낙 및 응답 요청 확인 메시지 전송 (ACK, SYN)
    3. 클라이언트는 확인 ACK 전달하고 연결. (ACK)

- 4-way Handsahking
*연결을 종료하는 과정이다. (가상회선 해제)*  
    1. 데이터를 전부 송신한 클라이언트가 서버에게 연결 해제하겠다는 메시지 전송 (FIN)
    2. 서버가 이를 확인했다는 메시지를 전송하고(ACK), 서버에서 남은 패킷을 모두 송신할 때까지 클라이언트는 대기 상태(TIME_WAIT)가 된다.
    3. 송신이 끝났으면 서버는 클라이언트에게 연결 종료 요청에 합의한다는 의미로 플래그를 전송 (FIN)
    4. 클라이언트는 확인했다는 메시지를 전송(ACK)



### 💡 3-way handshaking 과정에서 클라이언트가 서버가 보낸 ACK+SYN을 받지 못하면?  
- 클라이언트는 서버에게 SYN 세그먼트를 보내고 시간을 잰다. 그리고 Timeout이 되기 전까지 서버에게 ACK, SYN 세그먼트가 오지 않으면 클라이언트는 다시 SYN 세그먼트를 보내고 수신을 대기한다.

### 💡 만약 Server에서 FIN 세그먼트를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?  
- 만약, 클라이언트가 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 유실될 것이다.
- 따라서 이러한 현상에 대비하여 클라이언트는 FIN을 수신하더라도 일정시간(디폴트 240초)동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정(TIME_WAIT)을 거친다.


## Day02
### 💡 쿠키와 세션을 사용하는 이유를 HTTP 특징과 연관지어서 설명해주세요.
HTTP는 Stateless , Connectionless 라는 특징이 있기 때문에 상태 정보를 유지할 수 없었다. 예를들어, 쇼핑을 하기 위해서 로그인을 했음에도 페이지를 이동할 때마다 다시 로그인해야 하는 일이 발생한다. 
그래서 클라이언트가 로그인 등으로 한 번 사용자 인증을 하면, 그 인증을 유지할 수 있도록 쿠키와 세션을 사용한다.


### 💡 보안성이 낮은 쿠키 대신 세션을 사용하면 되는데 그렇게 하지않는 이유는 무엇일까요?
모든 정보를 세션에 저장하면 서버의 메모리를 과도하게 사용하게 되어 서버에 무리가 간다.
따라서, 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여 서버 자원의 낭비를 방지해야한다.


### 💡 HTTP & HTTPS에 대해 설명해주세요.
- HTTP
    - HTTP는 웹 상에서 클라이언트와 서버간에 데이터를 주고받을 수 있도록 해주는 프로토콜이다.
    - 평문 통신(암호화 되지 않은 통신)이기 때문에 도청 가능하고, 통신 상대를 확인 하지 않아서 위장이 가능하다. 또한 완전성을 증명할 수 없기 때문에 변조할 수 있다. 따라서 보안에 취약하다.
- HTTPS
    - HTTPS는 HTTP에 보안을 추가된 프로토콜을 말한다.
    - HTTP의 약점을 보완하기 위해 나온 것이 HTTPS이다. HTTPS는 중간에 SSL, TLS 암호화 계층을 거쳐서 패킷을 암호화하여 사용한다.
    - 네트워크 상에서 열람, 수정이 불가능하므로 안전하다.
    - 단점
        - 암호화를 하는 과정이 웹 서버에 부하를 준다.
        - HTTP에 비해 느리다.
        - 인터넷 연결이 끊긴 경우 재인증 시간이 소요된다.
            - HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다.
            - 이와 달리 HTTPS는 소켓(데이터를 주고 받는 경로) 자체에서 인증을 하는데 인터넷 연결이 끊기면 소켓도 끊어져서 다시 HTTPS 인증이 필요하다.
        - HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다.


### 💡 SSL 통신 방법에 대해 설명해주세요.
공개키와 대칭키 암호화 방식을 사용한다.


### 💡 네트워크에서 프록시의 종류 두가지를 말하시오
프록시란 클라이언트와 서버 사이에서 중계 기능을 하는 서버를 말한다. 캐시, 보안, 트래픽 분산 등 여러 장점이 있다.

- 포워드 프록시
    - 일반적인 프록시를 말하고 클라이언트가 서버로 요청할 때 직접 요청하지 않고 먼저 프록시 서버를 통해 요청하는 방식
    - 캐싱을 이용한 성능 향상
        - 자주 사용하는 데이터를 캐시에 저장해두고 사용
    - 익명성 보장
        - 서버는 프록시의 요청을 받기 때문에 누가 보냈는지 알 수 없다.

- 리버스 프록시
    - 클라리언트가 인터넷에 데이터를 요청하면 리버스 프록시가 이 요청을 받아 내부 서버에서 데이터를 받은 후 클라이언트에 전달한다.
    - 보안성이 좋다
        - 실제 서버의 정보가 노출되지 않는다.
    - 로드밸런싱
        - 부하 분산

### 💡 로드밸런싱이 필요해진 배경을 설명하시오.
로드밸런싱이란 하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버로 분산처리하여 서버의 부하, 속도 저하 등을 해결해주는 것을 말한다.

- 문제 발생
    - 웹 사이트에 접속하는 수가 늘어나면서 서버 1대로 모든 접속자의 트래픽을 감당하기 어려웠다.
- 문제 해결
    - Scale-up 
        - 서버 자체의 성능을 높이는 방법.
    - Scale-out
        - 서버를 추가해서 여러대의 서버를 두는 방법.
        - 트래픽을 여러대의 서버에 균등하게 분배하기 위해서 로드밸런서가 필요하다.
- Scale-out의 장점
    - 서버의 하드웨어를 업그레이드 하는 비용보다 서버 한대를 증설하는 비용이 더 적다.
    - 서버가 여러대라 무중단 서비스를 이용할 수 있다.

### 💡 로드밸런싱의 방법을 두 가지 이상 설명하시오.
- 라운드 로빈(Round Robin)
    - 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식
    - 서버와의 연결이 오래 지속되지 않는 경우 적합
- Least Connections
    - 연결 개수가 가장 적은 서버를 선택하는 방식
    - 트래픽으로 세션이 길어지는 경우 적합
- Source
    - 사용자 IP를 해싱하여 분배하는 방식
    - 사용자가 항상 동일한 서버로 연결

## Day03
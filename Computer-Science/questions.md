# ❓ Questions
## [Day1(2021.06.10)](#Day01)  [Network]
- HTTP 메소드 중 GET과 POST를 비교하여 설명해주세요.
- 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유? 
- 그 외에 다른 메소드 방식을 설명해주세요.
- PUT & PATCH 차이점을 설명해주세요.
- TCP와 UDP에 대해 설명해주세요.
- 흐름제어와 혼잡제어에 대해 설명해주세요.
- TCP의 연결(3-way handshaking)과 해제(4-way handshaking) 과정을 설명해주세요.
- 만약 Server에서 FIN 세그먼트를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?

## [Day2(2021.06.17)](#Day02)   [Network]
- 쿠키와 세션을 사용하는 이유를 HTTP 특징과 연관지어서 설명해주세요.
- 보안성이 낮은 쿠키 대신 세션을 사용하면 되는데 그렇게 하지않는 이유는 무엇일까요?
- HTTP & HTTPS에 대해 설명해주세요.
- 네트워크에서 프록시의 종류 두가지를 말하시오
- 로드밸런싱이 필요해진 배경을 설명하시오.
- 로드밸런싱의 방법을 두 가지 이상 설명하시오.

## [Day3(2021.06.24)](#Day03)   [Network + OS]
- CORS란 무엇인가요?
- CORS에서 Cross-Origin이 의미하는 바는 무엇인가요?
- CORS 정책이 필요한 이유는 무엇인가요?
- REST란?
- REST의 장단점은 무엇인가요?
- API란?
- REST API는 무엇인가요?
- RESTfull 한 웹서비스란 무엇을 말하나요?
- DNS란 무엇인가요?
- DNS가 필요한 이유는 무엇인가요?
- www.naver.com을 쳤을 때 일어나는 일에 대해 설명해주세요.

- 프로세스와 스레드를 비교 설명해주세요.
- 멀티 프로세스, 멀티 스레드, 멀티 코어의 개념을 비교해주세요.
- 인터럽트가 필요한 이유는?

- 시스템 콜이란?
- 시스템 콜을 사용하는 이유를 설명해주세요.
- PCB란?
- PCB가 필요한 이유를 설명해주세요.
- PCB는 어떻게 관리되는가?
- Context Switching 이란?
- Context Switching의 Overhead란?
- IPC란?
- IPC 종류를 3가지 이상 말헤주세요.


## [Day4(2021.07.03)](#Day04)   [OS]
- 상호배제란 무엇인가요?
- 세마포어와 뮤텍스를 비교 설명해주세요.
- 교착 상태에 대해서 설명해주세요.
- 교착 상태의 발생 조건 4가지는 무엇인가요?
- 교착 상태를 해결할 수 있는 방법은 어떤 것이 있을까요?
- 스케줄링이란 무엇이고, 어떤 목적으로 사용되나요?
- 선점 스케줄링과 비선점 스케줄링은 어떤 차이를 갖나요?
- 스케줄링 알고리즘에는 어떤 것이 있나요? 해당 알고리즘을 아는대로 설명해주세요.

- 메모리란?
- 논리주소(Logical Address)와 물리주소(Physical Address)를 비교 설명해주세요.
- MMU(Memory Management Unit)에 대해 설명해주세요.
- MMU안에 존재하는 레지스터(Relocation/Limit Register) 에 대해 설명해주세요.
- cpu가 346번지에 있는 내용을 요청했을 때, 어떻게 동작하는지, 어느 위치에서 내요을 가져오는지 설명해주세요. (단, relocation register의 값은 14000이다.)
- limit register가 존재하는 이유는 무엇일까요?
- 외부 단편화란?
- 연속 메모리 할당 방식에 대해 설명해주세요.
- Compaction 방식에 대해 설명해주세요.
- Compaction 방식의 문제점은 무엇일까요?

- 페이징과 세그먼테이션이 필요한 이유를 말하시오
- 페이징과 세그먼테이션의 장단점을 비교하시오
- 페이지 교체 알고리즘 종류와 간단한 설명을 하시오
- 페이지 교체 알고리즘 중 FIFO알고리즘의 문제점에 대해 설명하시오

## Day01
### 💡 HTTP 메소드 중 GET과 POST를 비교하여 설명해주세요.
- GET, POST 메소드는 HTTP 프로토콜을 이용해서 서버에 데이터(요청 정보)를 `전달`할 때 사용하는 방식이다.
- 이 때, HTTP 요청에 포함되는 메소드는 서버가 클라이언트의 요청에 응답하기 위해서 수행해야할 `행동`을 나타내는 역할을 한다.
- GET은 가져올 때, POST는 수행할 때 사용한다.
- GET
    - 서버로부터 정보를 조회하는데 사용한다. 
    - URL에 요청 정보를 포함하여 전송한다.
    - 데이터의 크기는 제한적이다. (한 번 요청 시 전송 데이터(주솟값 + 파라미터)의 양은 255자로 제한된다.)
    - 보안에 취약하다.
    - 캐싱할 수 있다. 따라서 POST 방식보다 빠르다.
        - 캐싱이란 한번 접근 후, 또 요청할시 빠르게 접근하기 위해 레지스터에 데이터를 저장시켜 놓는 것.
- POST
    - 서버의 값이나 상태를 바꾸기 위해 사용한다.
    - HTTP Body에 데이터를 포함해서 전달한다. 객체 등
    - 대용량 데이터를 전송할 수 있다.
    - GET 방식보다 보안상 안전하다.



### 💡 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?  
- 먼저 POST 방식은 안전X, 멱등X 하게 설계되었기 때문에 원하는 조회 결과를 얻을 수 없습니다.
- 반면에 GET 방식은 Idempotent(멱등)하게 설계되었기 때문에 한 번을 조회하던, 여러번 조회를 하던 언제나 동일한 응답이 돌아오게 됩니다. 따라서 웹페이지 조회, 게시판 조회 등 조회를 하는데 GET 방식을 사용한다.
- 웹에서 모든 리소스는 링크(Link) 할 수 있는 URL이 필요하다.
    - 다른 사람한테 웹 페이지 주소를 공유하기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다. 즉, 어떤 웹페이지로 바로 이동하기 위해서는 해당 링크의 정보가 필요하다.
    - 그런데 POST는 요청 데이터가 Body에 담겨 있어서 링크 정보를 가져올 수 없기 때문에 GET방식을 사용한다.



### 💡 그 외에 다른 메소드 방식을 설명해주세요.
- PUT 요청은 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성한다.
- PATCH 요청은 서버에 존재하는 데이터를 일부 수정한다. 보내지 않은 필드는 수정되지 않는다.
- DELETE 요청은 서버에 데이터를 제거할 것을 요청. 존재하지 않아도 동일하게 동작한다.



### 💡 PUT & PATCH 차이점을 설명해주세요.
- PUT 요청은 모든 데이터를 수정하는 역할을 한다. 만약 데이터 수정 시에, 보내지 않은 데이터가 있다면 해당 값은 null로 수정된다.
- PATCH 요청은 일부 데이터만을 수정하는 역할을 한다. 따라서 보내지 않은 필드는 수정되지 않는다.



### 💡 TCP와 UDP에 대해 설명해주세요.  
- TCP
    - 신뢰성 있는 데이터 통신을 가능하게 해주는 프로토콜이다.
    - 연결형 서비스로 가상 회선 방식을 이용한 일대일 연결만 가능하다.
    - 흐름제어, 혼잡제어, 오류제어를 제공하기 때문에 신뢰성을 보장된다.
    - 데이터의 순차 전송을 보장한다.
    - 패킷을 조금만 손실해도 재전송을 한다.
    - 매번 Connection을 연결해야 하기 때문에 속도가 상대적으로 느리다.
    - 높은 신뢰도를 요하는 서비스에 적합
        - HTTP통신, 이메일, 파일 전송

- UDP
    - TCP보다 신뢰성을 떨어지지만, 전송 속도가 일반적으로 빠른 프로토콜이다.
    - 비연결형 서비스로 연결 설정 없이 단방향으로로 데이터를 전송한다.
    - 흐름제어, 혼잡제어를 제공하지 않기 때문에 신뢰성이 낮다.
    - 속도가 빠르다.
    - 신뢰성이 중요하지 않은 서비스에 적합
        - 영상 스트리밍, DNS



### 💡 흐름제어와 혼잡제어에 대해 설명해주세요.  
- 흐름제어
    - 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절해서 수신자의 버퍼 오버플로우를 방지하기 위한 방법이다.
- 혼잡제어
    - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 송신측에서 데이터를 보내는 속도를 제어하는 방법이다.



### 💡 TCP의 연결(3-way handshaking)과 해제(4-way handshaking) 과정을 설명해주세요.  
- 3-way Handshaking
*데이터를 전송하기 위해 네트워크 연결을 설정하는 과정이다. (가상회선을 수립)*  
    1. 클라이언트가 서버측에 연결 요청 메시지 전송 (SYN)
        - 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자(n)로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    2. 서버는 클라이언트의 요청을 승낙 및 응답 요청 확인 메시지 전송 (ACK, SYN)
    3. 클라이언트는 확인 ACK 전달하고 연결. (ACK)

- 4-way Handsahking
*연결을 종료하는 과정이다. (가상회선 해제)*  
    1. 데이터를 전부 송신한 클라이언트가 서버에게 연결 해제하겠다는 메시지 전송 (FIN)
    2. 서버가 이를 확인했다는 메시지를 전송하고(ACK), 서버에서 남은 패킷을 모두 송신할 때까지 클라이언트는 대기 상태(TIME_WAIT)가 된다.
    3. 송신이 끝났으면 서버는 클라이언트에게 연결 종료 요청에 합의한다는 의미로 플래그를 전송 (FIN)
    4. 클라이언트는 확인했다는 메시지를 전송(ACK)



### 💡 3-way handshaking 과정에서 클라이언트가 서버가 보낸 ACK+SYN을 받지 못하면?  
- 클라이언트는 서버에게 SYN 세그먼트를 보내고 시간을 잰다. 그리고 Timeout이 되기 전까지 서버에게 ACK, SYN 세그먼트가 오지 않으면 클라이언트는 다시 SYN 세그먼트를 보내고 수신을 대기한다.

### 💡 만약 Server에서 FIN 세그먼트를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?  
- 만약, 클라이언트가 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 유실될 것이다.
- 따라서 이러한 현상에 대비하여 클라이언트는 FIN을 수신하더라도 일정시간(디폴트 240초)동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정(TIME_WAIT)을 거친다.


## Day02
### 💡 쿠키와 세션을 사용하는 이유를 HTTP 특징과 연관지어서 설명해주세요.
HTTP는 Stateless , Connectionless 라는 특징이 있기 때문에 상태 정보를 유지할 수 없었다. 예를들어, 쇼핑을 하기 위해서 로그인을 했음에도 페이지를 이동할 때마다 다시 로그인해야 하는 일이 발생한다. 
그래서 클라이언트가 로그인 등으로 한 번 사용자 인증을 하면, 그 인증을 유지할 수 있도록 쿠키와 세션을 사용한다.


### 💡 보안성이 낮은 쿠키 대신 세션을 사용하면 되는데 그렇게 하지않는 이유는 무엇일까요?
모든 정보를 세션에 저장하면 서버의 메모리를 과도하게 사용하게 되어 서버에 무리가 간다.
따라서, 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여 서버 자원의 낭비를 방지해야한다.


### 💡 HTTP & HTTPS에 대해 설명해주세요.
- HTTP
    - HTTP는 웹 상에서 클라이언트와 서버간에 데이터를 주고받을 수 있도록 해주는 프로토콜이다.
    - 평문 통신(암호화 되지 않은 통신)이기 때문에 도청 가능하고, 통신 상대를 확인 하지 않아서 위장이 가능하다. 또한 완전성을 증명할 수 없기 때문에 변조할 수 있다. 따라서 보안에 취약하다.
- HTTPS
    - HTTPS는 HTTP에 보안을 추가된 프로토콜을 말한다.
    - HTTP의 약점을 보완하기 위해 나온 것이 HTTPS이다. HTTPS는 중간에 SSL, TLS 암호화 계층을 거쳐서 패킷을 암호화하여 사용한다.
    - 네트워크 상에서 열람, 수정이 불가능하므로 안전하다.
    - 단점
        - 암호화를 하는 과정이 웹 서버에 부하를 준다.
        - HTTP에 비해 느리다.
        - 인터넷 연결이 끊긴 경우 재인증 시간이 소요된다.
            - HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다.
            - 이와 달리 HTTPS는 소켓(데이터를 주고 받는 경로) 자체에서 인증을 하는데 인터넷 연결이 끊기면 소켓도 끊어져서 다시 HTTPS 인증이 필요하다.
        - HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다.


### 💡 SSL 통신 방법에 대해 설명해주세요.
공개키와 대칭키 암호화 방식을 사용한다.


### 💡 네트워크에서 프록시의 종류 두가지를 말하시오
프록시란 클라이언트와 서버 사이에서 중계 기능을 하는 서버를 말한다. 캐시, 보안, 트래픽 분산 등 여러 장점이 있다.

- 포워드 프록시
    - 일반적인 프록시를 말하고 클라이언트가 서버로 요청할 때 직접 요청하지 않고 먼저 프록시 서버를 통해 요청하는 방식
    - 캐싱을 이용한 성능 향상
        - 자주 사용하는 데이터를 캐시에 저장해두고 사용
    - 익명성 보장
        - 서버는 프록시의 요청을 받기 때문에 누가 보냈는지 알 수 없다.

- 리버스 프록시
    - 클라리언트가 인터넷에 데이터를 요청하면 리버스 프록시가 이 요청을 받아 내부 서버에서 데이터를 받은 후 클라이언트에 전달한다.
    - 보안성이 좋다
        - 실제 서버의 정보가 노출되지 않는다.
    - 로드밸런싱
        - 부하 분산

### 💡 로드밸런싱이 필요해진 배경을 설명하시오.
로드밸런싱이란 하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버로 분산처리하여 서버의 부하, 속도 저하 등을 해결해주는 것을 말한다.

- 문제 발생
    - 웹 사이트에 접속하는 수가 늘어나면서 서버 1대로 모든 접속자의 트래픽을 감당하기 어려웠다.
- 문제 해결
    - Scale-up 
        - 서버 자체의 성능을 높이는 방법.
    - Scale-out
        - 서버를 추가해서 여러대의 서버를 두는 방법.
        - 트래픽을 여러대의 서버에 균등하게 분배하기 위해서 로드밸런서가 필요하다.
- Scale-out의 장점
    - 서버의 하드웨어를 업그레이드 하는 비용보다 서버 한대를 증설하는 비용이 더 적다.
    - 서버가 여러대라 무중단 서비스를 이용할 수 있다.

### 💡 로드밸런싱의 방법을 두 가지 이상 설명하시오.
- 라운드 로빈(Round Robin)
    - 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식
    - 서버와의 연결이 오래 지속되지 않는 경우 적합
- Least Connections
    - 연결 개수가 가장 적은 서버를 선택하는 방식
    - 트래픽으로 세션이 길어지는 경우 적합
- Source
    - 사용자 IP를 해싱하여 분배하는 방식
    - 사용자가 항상 동일한 서버로 연결

## Day03
### 💡 CORS란 무엇인가요?
- HTTP 헤더를 사용해서 다른 Origin의 리소스에 접근할 수 있도록 하는 것을 말한다.

### 💡 CORS에서 Cross-Origin이 의미하는 바는 무엇인가요?
- 다른 출처, 리소스
### 💡 CORS 정책이 필요한 이유는 무엇인가요?
- 클라이언트가 안전하게 다른 Origin으로부터 리소스를 얻을 수 있도록 하기 위해서

### 💡 REST란?
웹의 장점을 최대한 활용한 아키텍처를 말한다.

### 💡 REST의 장단점은 무엇인가요?
- HTTP 프로토콜을 그대로 사용하므로 별도의 인프라를 구출할 필요가 없다.
- HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
- REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
- 서버와 클라이언트의 역할을 명확하게 분리한다.

### 💡 API란?
- 응용프로그램에서 데이터를 주고 받기 위한 방법

### 💡 REST API는 무엇인가요?
- REST 기반으로 서비스 API를 구현한 것을 말한다.

### 💡 RESTfull 한 웹서비스란 무엇을 말하나요?
REST API의 설계 의도를 명확하게 지켜주는 것을 말한다. 
각 구성요소들의 역할이 완벽하게 분리해야하고, URI를 명확한 정의해야한다.

### 💡 DNS란 무엇인가요?
- 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행는 것을 말한다.

### 💡 DNS가 필요한 이유는 무엇인가요?
- 원격의 컴퓨터/호스트에 접속하기 위해서는 IP주소를 이용하여야 하지만, 숫자의 연속인 IP주소를 일일이 외울 수 없기때문에 쉽게 기억할 수 있는 이러한 주소 체계가 만들어진 것이다.

### 💡 www.naver.com을 쳤을 때 일어나는 일에 대해 설명해주세요.
- 다시 정리할 것

### 💡 프로세스와 쓰레드를 비교 설명해주세요.
- 프로세스
    - 메모리에 올라와서 실행되고 있는 프로그램의 인스턴스를 말한다.
    - 특징
        - 운영체제로부터 독립된 메모리 영역을 할당받는다.
        - 독립적이기 때문에 통신을 하기 위해서는 IPC를 사용해야 한다.
        - 최소 1개의 쓰레드를 가지고 있다.
- 스레드
    - 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위를 말한다.
    - 특징
        - 프로세스 내에 존재하고, 프로세스가 할당받은 자원을 이용하여 실행된다.
        - 쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, Code, Data, Heap 영역은 공유한다.(Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함이다.)
        - 쓰레드는 프로세스의 자원을 공유하기 때문에 다른 쓰레드에 의한 결과를 즉시 확인할 수 있다

### 💡 멀티 프로세스, 멀티 스레드, 멀티 코어의 개념을 비교해주세요.
- 멀티 프로세스
    - 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것이다.
    - 특징
        - 1개의 프로세스가 죽어도 자식 프로세스 이외의 다른 프로세스들은 계속 실행된다.
        - Context Switching을 위한 오버헤드(캐시 초기화, 인터럽트 등)가 발생한다.
        - 프로세스는 각각 독립적인 메모리를 할당받았기 때문에 통신하는 것이 어렵다.
- 멀티 쓰레드
    - 하나의 프로그램을 여러 개의 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리하도록 하는 것이다.
    - 특징
        - 프로세스를 위해 자원을 할당하는 시스템콜이나 Context Switching의 오버헤드를 줄일 수 있다.
        - 쓰레드는 메모리를 공유하기 때문에, 통신이 쉽고 자원을 효율적으로 사용할 수 있다.
        - 하나의 쓰레드에 문제가 생기면 전체 프로세스가 영향을 받는다.
        - 여러 쓰레드가 하나의 자원에 동시에 접근하는 경우 자원 공유(동기화)의 문제가 발생할 수 있다.

### 💡 인터럽트란?
- 실행중인 프로그램을 중단하고 우선순위가 높은 프로그램에게 CPU를 할당하여 실행하는것을 말한다.

### 💡 인터럽트가 필요한 이유는?
- CPU와 I/O의 속도 차이를 극복하기 위해 인터럽트가 필요(입출력 연산이 CPU 명령 수행속도보다 현저히 느리기 때문이다.)
- CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요한 경우에 발생한다.

### 💡 시스템 콜이란?
- 커널 영역의 기능을 사용자 모드가 접근하게 도와주는 기능을 시스템 콜이라고 한다.

### 💡 시스템 콜을 사용하는 이유를 설명해주세요.
- 유저 애플리케이션이 운영체제의 치명적인 권한(데이터 수정/삭제)를 막기 위해서 사용한다.
- 따라서 직접적인 하드웨어 요청이나 기타 시스템 요청은 운영체제가 제공하는 시스템 콜을 통해서 호출하도록 제공한다.

### 💡 PCB란?
- 운영체제가 프로세스를 제어하기 위해서 정보를 저장해놓은 곳. 프로세스의 상태 정보를 저장하는 구조체이다.

### 💡 PCB가 필요한 이유를 설명해주세요.
- 프로세스의 상태 관리, 문맥 교환(Context Switching)을 위해 필요하다.

### 💡 PCB는 어떻게 관리되는가?
- Linked List 방식으로 관리한다.
- PCB List Head에 PCB들이 생성될 때마다 붙게 된다. 주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이하다.
- 즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료시 제거된다.

### 💡 문맥 교환(Context Switching) 이란?
- 문맥 교환이란 CPU가 이전의 프로세스 상태를 PCB에 보관하고, 다음 프로세스의 정보를 PCB에 읽어서 적재하는 과정을 말한다.

### 💡 Context Switching의 Overhead란?
문맥 교환에 소요되는 시간은 시스템 입장에서 볼 때 일종의 오버헤드라고 할 수 있다. 따라서 타이머 인터럽트 시간을 너무 짧게하면 프로세스간 문맥 교환이 너무 자주 일어나 오버헤드가 커지게 된다.


### 💡 IPC란?
프로세스는 독립적으로 실행된다. 독립되어있다는 것은 다른 프로세스에게 영향을 받지 않는다는 것이다. 이런 독립적 구조를 가진 프로세스 간의 통신을 해야 하는 상황이 있을 것이고, 이를 가능하도록 해주는 것이 IPC 통신이다. 즉, `내부 프로세스들 끼리 통신을 하는 것`을 말한다.

### 💡 IPC의 종류를 3가지 이상 말해주세요.
- PIPE
- Named PIPE
- Message Queue
- Shared Memory
- Memory Map
- socket


## Day04
### 💡 상호배제란 무엇인가요?
- 여러 프로세스나 쓰레드가 공유 자원에 접근하는 것

### 💡 세마포어와 뮤텍스를 비교 설명해주세요.
- 세마포어는 count를 주어 count 값만큼 프로세스/스레드가 접근 가능하도록 하는 기법
- 뮤텍스는 lock/unlock으로 권한을 가진 프로세스/스레드만 접근할 수 있도록하는 기법

### 💡 교착 상태에 대해서 설명해주세요.


### 💡 교착 상태의 발생 조건 4가지는 무엇인가요?


### 💡 교착 상태를 해결할 수 있는 방법은 어떤 것이 있을까요?

### 💡 스케줄링이란 무엇이고, 어떤 목적으로 사용되나요?


### 💡 선점 스케줄링과 비선점 스케줄링은 어떤 차이를 갖나요?

### 💡 스케줄링 알고리즘에는 어떤 것이 있나요? 해당 알고리즘을 아는대로 설명해주세요.


### 💡 메모리란?
주소 덩어리, 인덱싱 할 수 있는 큰 주소 배열

### 💡 논리주소(Logical Address)와 물리주소(Physical Address)를 비교 설명해주세요.
- 논리주소(Logical Address)
    - CPU가 보는 주소
    - 프로세스마다 독립적으로 가지는 주소 공간
    - 각 프로세스마다 0번지부터 시작
- 물리주소(Physical Address)
    - 메모리에 실제 올라가는 위치

### 💡 MMU(Memory Management Unit)에 대해 설명해주세요.
Logical Address 를 Physical Address 로 매핑해주는 하드웨어 장치를 말한다.

### 💡 MMU안에 존재하는 레지스터(Relocation/Limit Register) 에 대해 설명해주세요.
- Relocation Register (Base Register) : 접근할 수 있는 물리적 메모리 주소의 최소값
- Limit Register : 논리적 주소의 범위
### 💡 cpu가 346번지에 있는 내용을 요청했을 때, 어떻게 동작하는지, 어느 위치에서 내요을 가져오는지 설명해주세요. (단, relocation register의 값은 14000이다.)

### 💡 limit register가 존재하는 이유는 무엇일까요?
불법 접근으로 다른 데이터를 가져오는 것을 막기 위해

### 💡 외부 단편화란?
외부 단편화는 메모리에 프로세스가 할당될 만큼 충분한 공간이 존재하지만 공간이 쪼개어져서 프로세스를 넣을 수 없는 것을 말한다.

### 💡 연속 메모리 할당 방식에 대해 설명해주세요.
- 최초 적합(First-fit)
    - 순차적으로 탐색하여 제일 먼저 발견한 적절하게 들어갈 수 있는 곳을 찾아 프로세스를 적재하는 방법
- 최적 적합(Best-fit)
    - 제일 적절하게 들어갈 수 있는 곳을 찾아 프로세스를 적재하는 방법
- 최악 적합(Worst-fit)
    - 크기와 제일 안 맞는 공간(프로세스보다 큰 메모리 공간 중에서)에 프로세스를 넣는 방식

### 💡 Compaction 방식에 대해 설명해주세요.
빈 공간을 한 곳으로 모으는 방식이다.

### 💡 Compaction 방식의 문제점은 무엇일까요?
한 곳으로 모으기 위해서는 메모리를 움직여야 하는데 이 때 발생하는 비용이 크고, 어느 빈 공간을 움직이는 것이 좋은지에 관한 최적 알고리즘이 존재하지 않는다.

### 💡 페이징과 세그먼테이션이 필요한 이유를 말하시오
- 
### 💡 페이징과 세그먼테이션의 장단점을 비교하시오
- 페이징 기법을 사용하게되면 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애 외부 단편화 문제점을 해결할 수 있습니다.
- 하지만 그만큼 Mapping 과정 또한 늘어나기 때문에 Trade-Off 가 발생할 수 있습니다. 그리고 보통 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있습니다.


### 💡 페이지 교체 알고리즘 종류와 간단한 설명을 하시오
-
### 💡 페이지 교체 알고리즘 중 FIFO알고리즘의 문제점에 대해 설명하시오
- 
